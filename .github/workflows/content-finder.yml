name: Content Finder

on:
  workflow_dispatch:
    inputs:
      query:
        description: 'Text or regex to search for (e.g. invoice 2023 or ^ERROR:)'
        required: true
        type: string
      use_regex:
        description: 'Treat query as regex (true) or plain text (false)'
        required: true
        type: boolean
        default: false
      drives:
        description: 'Comma/space list of drives (e.g. C:,D:). Blank = all local drives.'
        required: false
        type: string
        default: ''
      extensions:
        description: 'Limit to extensions (comma/space, e.g. .txt,.md,.log). Blank = common text types.'
        required: false
        type: string
        default: ''
      size_max_mb:
        description: 'Skip files larger than this (MB). Blank = 50.'
        required: false
        type: number
      include_hidden:
        description: 'Include hidden/system items'
        required: true
        type: boolean
        default: true
      context_lines:
        description: 'Lines of context before/after each hit'
        required: false
        type: number
        default: 1

jobs:
  search:
    runs-on: [self-hosted, windows]
    defaults:
      run:
        shell: powershell
    steps:
      - name: Search file contents
        run: |
          $ErrorActionPreference = 'Stop'

          $query         = "${{ inputs.query }}"
          $useRegex      = "${{ inputs.use_regex }}" -eq 'true'
          $driveInput    = "${{ inputs.drives }}"
          $extInput      = "${{ inputs.extensions }}"
          $includeHidden = "${{ inputs.include_hidden }}" -eq 'true'
          $ctx           = [int]("${{ inputs.context_lines }}")
          if ($ctx -lt 0) { $ctx = 0 }

          # Drives
          if ([string]::IsNullOrWhiteSpace($driveInput)) {
            $drives = (Get-PSDrive -PSProvider FileSystem).Root
          } else {
            $drives = $driveInput -split '[,\s]+' | Where-Object { $_ } | ForEach-Object {
              if ($_ -match '^[A-Za-z]:\\?$') { if ($_.EndsWith('\')) { $_ } else { "$_\" } } else { "$_\" }
            }
          }

          # Extensions allowlist
          if ([string]::IsNullOrWhiteSpace($extInput)) {
            $exts = @('.txt','.md','.log','.csv','.json','.xml','.yml','.yaml','.ini','.conf','.cfg','.ps1','.bat','.cmd','.py','.js','.ts','.html','.css')
          } else {
            $exts = $extInput -split '[,\s]+' | Where-Object { $_ } | ForEach-Object {
              if ($_ -notmatch '^\.') { ".$_" } else { $_ }
            }
          }

          # Size limit
          $sizeMaxMB = ("${{ inputs.size_max_mb }}")
          if ([string]::IsNullOrWhiteSpace($sizeMaxMB)) { $sizeMaxMB = 50 }
          $sizeMaxBytes = [int64]([math]::Round([double]$sizeMaxMB * 1MB))

          Write-Host ("Query     : {0}" -f $query)
          Write-Host ("Regex     : {0}" -f $useRegex)
          Write-Host ("Drives    : {0}" -f ($drives -join ', '))
          Write-Host ("Exts      : {0}" -f ($exts -join ', '))
          Write-Host ("Max size  : {0} MB" -f $sizeMaxMB)
          if ($includeHidden) { Write-Host "Including hidden/system items" }

          $candidateFiles = New-Object System.Collections.Generic.List[string]

          foreach ($d in $drives) {
            try {
              $gciArgs = @{
                Path        = $d
                Recurse     = $true
                ErrorAction = 'SilentlyContinue'
                File        = $true
              }
              if ($includeHidden) { $gciArgs['Force'] = $true }

              Get-ChildItem @gciArgs |
                Where-Object { $exts -contains $_.Extension.ToLower() -and $_.Length -le $sizeMaxBytes } |
                ForEach-Object { $candidateFiles.Add($_.FullName) }

            } catch {
              # IMPORTANT: avoid "$d:" inside quotes; use a format string instead
              Write-Warning ("Skipping {0} due to access error: {1}" -f $d, $_.Exception.Message)
            }
          }

          Write-Host ("Candidate files: {0}" -f $candidateFiles.Count)

          $out  = Join-Path $env:RUNNER_TEMP 'content-hits.csv'
          $rows = New-Object System.Collections.Generic.List[object]

          # Batched Select-String to avoid arg length issues
          $batchSize = 500
          for ($i=0; $i -lt $candidateFiles.Count; $i += $batchSize) {
            $batch = $candidateFiles[$i..([Math]::Min($i+$batchSize-1,$candidateFiles.Count-1))]

            try {
              if ($useRegex) {
                $hits = Select-String -Path $batch -Pattern $query -SimpleMatch:$false -Context $ctx,$ctx -ErrorAction SilentlyContinue
              } else {
                $hits = Select-String -Path $batch -Pattern $query -SimpleMatch -Context $ctx,$ctx -ErrorAction SilentlyContinue
              }
            } catch {
              $hits = @()
            }

            foreach ($h in $hits) {
              $before = ($h.Context.PreContext -join ' ').Trim()
              $after  = ($h.Context.PostContext -join ' ').Trim()
              $line   = ($h.Line).Trim()
              $match  = ($h.Matches | ForEach-Object { $_.Value }) -join ' | '

              $fi = Get-Item $h.Path -ErrorAction SilentlyContinue
              $sizeMB = if ($fi) { [math]::Round($fi.Length/1MB,2) } else { $null }
              $time   = if ($fi) { $fi.LastWriteTime } else { $null }

              $rows.Add([PSCustomObject]@{
                Name       = $h.Filename
                FullName   = $h.Path
                LineNumber = $h.LineNumber
                Match      = $match
                Snippet    = $line
                Context    = ($before + ($(if($before -and $after){' ' } else {''})) + $after)
                SizeMB     = $sizeMB
                LastWrite  = $time
              })
            }
          }

          if ($rows.Count -eq 0) {
            Write-Host "No content matches."
            "Name,FullName,LineNumber,Match,Snippet,Context,SizeMB,LastWrite" | Out-File -Encoding UTF8 $out
          } else {
            Write-Host ("Found {0} hit(s). Saving CSV -> {1}" -f $rows.Count, $out)
            $rows |
              Sort-Object FullName, LineNumber |
              Export-Csv -NoTypeInformation -Encoding UTF8 -Path $out

            Write-Host "Top 15:"
            $rows | Select-Object -First 15 | Format-Table -AutoSize
          }

      - name: Upload results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: content-finder-results
          path: ${{ runner.temp }}/content-hits.csv
          if-no-files-found: warn
